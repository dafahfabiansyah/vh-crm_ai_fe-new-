-- Define enums
CREATE TYPE file_type_enum AS ENUM ('jpg', 'txt', 'pdf', 'png');
CREATE TYPE agent_type_enum AS ENUM ('AI', 'Human');
CREATE TYPE moved_by_enum AS ENUM ('AI', 'Human');
CREATE TYPE lead_status_enum AS ENUM ('unassigned', 'assigned', 'resolved');
CREATE TYPE message_type_enum AS ENUM ('text', 'media');

CREATE TABLE IF NOT EXISTS product_category (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS category_attributes (
    id UUID PRIMARY KEY,
    id_category UUID NOT NULL REFERENCES product_category(id) ON DELETE CASCADE,
    attribute_name VARCHAR(255) NOT NULL,
    is_required BOOLEAN NOT NULL,
    display_order INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS product (
    id UUID PRIMARY KEY,
    id_category UUID NOT NULL REFERENCES product_category(id) ON DELETE CASCADE,
    sku VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    stock INTEGER NOT NULL,
    price FLOAT NOT NULL,
    status BOOLEAN NOT NULL,
    image text,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- üõ†Ô∏è Fixed: Typo in table name 'prodcut_attributes'
CREATE TABLE IF NOT EXISTS product_attributes (
    id UUID PRIMARY KEY,
    id_product UUID NOT NULL REFERENCES product(id) ON DELETE CASCADE,
    id_category_attribute UUID NOT NULL REFERENCES category_attributes(id) ON DELETE CASCADE,
    value VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS department (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    head_id UUID ,
    is_active BOOLEAN DEFAULT true,
    created_by UUID NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS ai_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    behaviour TEXT,
    welcome_message TEXT,
    transfer_condition TEXT,
    model VARCHAR(255),
    history_limit INT,
    context_limit INT,
    message_await INT,
    message_limit INT,
    rajaongkir_enabled BOOLEAN DEFAULT false,
    rajaongkir_origin_district VARCHAR(255),
    rajaongkir_couriers TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP 
);

CREATE TABLE IF NOT EXISTS ai_agents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR NOT NULL,
    description TEXT,
    id_settings UUID NOT NULL REFERENCES ai_settings(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP 
);

CREATE TABLE IF NOT EXISTS agents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    identifier UUID NOT NULL,
    department UUID NULL REFERENCES department(id) ON DELETE CASCADE,
    agent_type agent_type_enum NOT NULL,
    is_active boolean NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


CREATE TABLE IF NOT EXISTS pipelines (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS platform_mapping (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_agent UUID,
    id_platform VARCHAR(255),
    agent_type agent_type_enum NOT NULL,
    is_active boolean NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS contacts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_platform VARCHAR(255),
    contact_identifier VARCHAR(255),
    push_name VARCHAR(255),
    last_message TEXT,
    last_message_at TIMESTAMP,
    unread_messages INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


CREATE TABLE IF NOT EXISTS stages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_pipeline UUID REFERENCES pipelines(id) ON DELETE SET NULL,
    id_agent UUID REFERENCES agents(id) ON DELETE SET NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    stage_order INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);



CREATE TABLE IF NOT EXISTS lead (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    potential_value FLOAT,
    notes TEXT,
    id_contact UUID REFERENCES contacts(id) ON DELETE SET NULL,
    assigned_to UUID  REFERENCES agents(id) ON DELETE SET NULL,
    id_pipeline UUID REFERENCES pipelines(id) ON DELETE SET NULL,
    id_stage UUID REFERENCES stages(id) ON DELETE SET NULL,
    moved_by moved_by_enum NOT NULL DEFAULT 'AI',
    status lead_status_enum NOT NULL DEFAULT 'unassigned',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);



CREATE TABLE IF NOT EXISTS chat_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_contact UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    message TEXT,
    type message_type_enum NOT NULL,
    media TEXT,
    from_me BOOLEAN,
    sent_at TIMESTAMP
);

CREATE TABLE IF NOT EXISTS deals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_lead UUID NOT NULL REFERENCES lead(id) ON DELETE CASCADE,
    description TEXT,
    amount TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);



-- Tables
CREATE TABLE IF NOT EXISTS knowledge_text (
    id UUID PRIMARY KEY,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS knowledge_website (
    id UUID PRIMARY KEY,
    url TEXT NOT NULL,
    title TEXT NOT NULL,
    html TEXT NOT NULL,
    metadata JSONB NOT NULL,
    scrape_type VARCHAR(20) DEFAULT 'single' CHECK (scrape_type IN ('single', 'batch')),
    parent_url TEXT,
    scraped_links_count INTEGER DEFAULT 0,
    scraping_status VARCHAR(20) DEFAULT 'pending' CHECK (scraping_status IN ('pending', 'processing', 'completed', 'failed')),
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS knowledge_qa (
    id UUID PRIMARY KEY,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS knowledge_file (
    id UUID PRIMARY KEY,
    file_url TEXT NOT NULL,
    file_type file_type_enum NOT NULL,
    extracted_text TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS knowledge (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_agent UUID NOT NULL REFERENCES ai_agents(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS knowledge_sources (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_knowledge UUID NOT NULL REFERENCES knowledge(id) ON DELETE CASCADE,
    source_id UUID NOT NULL,
    source_type VARCHAR(50) NOT NULL CHECK (source_type IN ('Text', 'Website', 'File', 'QA', 'Product')),
    status BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Web scraping jobs table for batch processing
CREATE TABLE IF NOT EXISTS web_scraping_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    parent_website_id UUID NOT NULL REFERENCES knowledge_website(id) ON DELETE CASCADE,
    start_url TEXT NOT NULL,
    max_links INTEGER DEFAULT 30,
    processed_links INTEGER DEFAULT 0,
    successful_links INTEGER DEFAULT 0,
    failed_links INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'cancelled')),
    error_message TEXT,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Individual scraped pages from batch jobs
CREATE TABLE IF NOT EXISTS scraped_pages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    job_id UUID NOT NULL REFERENCES web_scraping_jobs(id) ON DELETE CASCADE,
    website_id UUID NOT NULL REFERENCES knowledge_website(id) ON DELETE CASCADE,
    url TEXT NOT NULL,
    title TEXT,
    html TEXT,
    content_length INTEGER DEFAULT 0,
    scraping_status VARCHAR(20) DEFAULT 'pending' CHECK (scraping_status IN ('pending', 'processing', 'completed', 'failed', 'skipped')),
    error_message TEXT,
    scraped_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


-- ====================
-- Create Indexes
-- ====================

-- üß† If users table exists
-- CREATE INDEX idx_users_email ON users(email);
-- CREATE INDEX idx_users_type ON users(type);
-- CREATE INDEX idx_users_status ON users(status);

-- üß† If tenant table exists
-- CREATE INDEX idx_tenant_user ON tenant(id_user);
-- CREATE INDEX idx_tenant_status ON tenant(status);

-- ‚úÖ Agent mapping table (assumed exists somewhere else)
-- CREATE INDEX idx_agent_mapping_user ON agent_mapping(id_user);
-- CREATE INDEX idx_agent_mapping_tenant ON agent_mapping(id_tenant);
-- CREATE INDEX idx_agent_mapping_role ON agent_mapping(role);

-- ‚úÖ Platform session (assumed to exist elsewhere)
-- CREATE INDEX idx_platform_session_tenant ON platform_session(id_tenant);

-- ‚úÖ Subscription plans (assumed exists)
-- CREATE INDEX idx_subscription_plans_active ON subscription_plans(is_active);
-- CREATE INDEX idx_subscription_plans_popular ON subscription_plans(is_popular);

-- ‚úÖ Tenant subscription (assumed exists)
-- CREATE INDEX idx_tenant_subscription_tenant ON tenant_subscription(id_tenant);
-- CREATE INDEX idx_tenant_subscription_plan ON tenant_subscription(id_subscription);
-- CREATE INDEX idx_tenant_subscription_status ON tenant_subscription(status);
-- CREATE INDEX idx_tenant_subscription_dates ON tenant_subscription(start_date, end_date);

-- ‚úÖ Transactions (assumed exists)
-- CREATE INDEX idx_transactions_tenant ON transactions(id_tenant);
-- CREATE INDEX idx_transactions_type ON transactions(transaction_type);
-- CREATE INDEX idx_transactions_subscription ON transactions(id_subscription);
-- CREATE INDEX idx_transactions_created ON transactions(created_at);

-- ‚úÖ Usage tracking (assumed exists)
-- CREATE INDEX idx_usage_tracking_tenant ON usage_tracking(id_tenant);
-- CREATE INDEX idx_usage_tracking_month ON usage_tracking(usage_month);

-- Optional: more helpful indexes based on your tables
CREATE INDEX idx_contacts_platform ON contacts(id_platform);
CREATE INDEX idx_chat_log_contact ON chat_log(id_contact);
CREATE INDEX idx_deals_lead ON deals(id_lead);
CREATE INDEX idx_lead_stage ON lead(id_stage);
CREATE INDEX idx_lead_pipeline ON lead(id_pipeline);
CREATE INDEX idx_product_category ON product(id_category);
CREATE UNIQUE INDEX one_ai_agent_per_platform ON agents (department)
WHERE agent_type = 'AI';
CREATE INDEX idx_product_attributes_product ON product_attributes(id_product);
CREATE INDEX idx_knowledge_agent ON knowledge(id_agent);
CREATE INDEX idx_knowledge_sources_knowledge ON knowledge_sources(id_knowledge);
CREATE INDEX idx_knowledge_sources_source ON knowledge_sources(source_id, source_type);
CREATE INDEX idx_knowledge_sources_type ON knowledge_sources(source_type);

-- Web scraping indexes
CREATE INDEX idx_web_scraping_jobs_parent ON web_scraping_jobs(parent_website_id);
CREATE INDEX idx_web_scraping_jobs_status ON web_scraping_jobs(status);
CREATE INDEX idx_web_scraping_jobs_created ON web_scraping_jobs(created_at);
CREATE INDEX idx_scraped_pages_job ON scraped_pages(job_id);
CREATE INDEX idx_scraped_pages_website ON scraped_pages(website_id);
CREATE INDEX idx_scraped_pages_status ON scraped_pages(scraping_status);
CREATE INDEX idx_scraped_pages_url ON scraped_pages(url);
CREATE INDEX idx_knowledge_website_scrape_type ON knowledge_website(scrape_type);
CREATE INDEX idx_knowledge_website_status ON knowledge_website(scraping_status);
CREATE INDEX idx_knowledge_website_parent ON knowledge_website(parent_url);

-- ============================
-- Triggers: updated_at auto-update
-- ============================

-- Create reusable trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

-- Apply to all relevant tables
CREATE TRIGGER trg_update_knowledge_text BEFORE UPDATE ON knowledge_text
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_knowledge_website BEFORE UPDATE ON knowledge_website
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_knowledge_qa BEFORE UPDATE ON knowledge_qa
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_knowledge_file BEFORE UPDATE ON knowledge_file
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_product_category BEFORE UPDATE ON product_category
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_category_attributes BEFORE UPDATE ON category_attributes
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_product BEFORE UPDATE ON product
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_product_attributes BEFORE UPDATE ON product_attributes
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_department BEFORE UPDATE ON department
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_ai_settings BEFORE UPDATE ON ai_settings
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_ai_agents BEFORE UPDATE ON ai_agents
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_agents BEFORE UPDATE ON agents
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();


CREATE TRIGGER trg_update_platform_mapping BEFORE UPDATE ON platform_mapping
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_contacts BEFORE UPDATE ON contacts
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_pipelines BEFORE UPDATE ON pipelines
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_stages BEFORE UPDATE ON stages
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_lead BEFORE UPDATE ON lead
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Note: lead_transfer_history doesn't need an update trigger as it's append-only

CREATE TRIGGER trg_update_deals BEFORE UPDATE ON deals
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_knowledge BEFORE UPDATE ON knowledge
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_knowledge_sources BEFORE UPDATE ON knowledge_sources
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_web_scraping_jobs BEFORE UPDATE ON web_scraping_jobs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_scraped_pages BEFORE UPDATE ON scraped_pages
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================
-- Custom Integration Tables
-- ============================

-- Main custom integrations table
CREATE TABLE IF NOT EXISTS custom_integrations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    webhook_url TEXT NOT NULL,
    http_method VARCHAR(10) NOT NULL CHECK (http_method IN ('GET', 'POST')),
    content_type VARCHAR(100) DEFAULT 'application/json',
    timeout_seconds INTEGER DEFAULT 30,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Custom integration headers table (1NF compliant)
CREATE TABLE IF NOT EXISTS custom_integration_headers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_integration UUID NOT NULL REFERENCES custom_integrations(id) ON DELETE CASCADE,
    header_name VARCHAR(255) NOT NULL,
    header_value TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Custom integration fields table (dynamic input fields)
CREATE TABLE IF NOT EXISTS custom_integration_fields (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_integration UUID NOT NULL REFERENCES custom_integrations(id) ON DELETE CASCADE,
    field_name VARCHAR(255) NOT NULL,
    field_type VARCHAR(50) NOT NULL CHECK (field_type IN ('text', 'number', 'boolean', 'email', 'url', 'date', 'enum')),
    is_required BOOLEAN DEFAULT false,
    default_value TEXT,
    description TEXT,
    display_order INTEGER DEFAULT 0,
    enum_values TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- AI agent integrations mapping table
CREATE TABLE IF NOT EXISTS ai_agent_integrations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_ai_agent UUID NOT NULL REFERENCES ai_agents(id) ON DELETE CASCADE,
    id_integration UUID NOT NULL REFERENCES custom_integrations(id) ON DELETE CASCADE,
    is_enabled BOOLEAN DEFAULT true,
    trigger_condition TEXT,
    execution_order INTEGER DEFAULT 0,
    depends_on_integration UUID REFERENCES custom_integrations(id),
    requires_success BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(id_ai_agent, id_integration)
);

-- Integration execution logs table
CREATE TABLE IF NOT EXISTS integration_execution_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_ai_agent UUID NOT NULL REFERENCES ai_agents(id),
    id_integration UUID NOT NULL REFERENCES custom_integrations(id),
    id_contact UUID REFERENCES contacts(id),
    request_body TEXT,
    response_body TEXT,
    status_code INTEGER,
    success BOOLEAN,
    error_message TEXT,
    execution_duration_ms INTEGER,
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Integration field values table (store field values for each execution)
CREATE TABLE IF NOT EXISTS integration_field_values (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    id_execution_log UUID NOT NULL REFERENCES integration_execution_logs(id) ON DELETE CASCADE,
    id_field UUID NOT NULL REFERENCES custom_integration_fields(id),
    field_value TEXT,
    enum_values TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Add comments for documentation
COMMENT ON TABLE custom_integrations IS 'Main table for storing custom API integrations configuration';
COMMENT ON TABLE custom_integration_headers IS 'HTTP headers for custom integrations (1NF compliant)';
COMMENT ON TABLE custom_integration_fields IS 'Dynamic input fields that AI agents can populate before API calls';
COMMENT ON TABLE ai_agent_integrations IS 'Mapping table between AI agents and their enabled integrations';
COMMENT ON TABLE integration_execution_logs IS 'Logs of integration API calls for debugging and analytics';
COMMENT ON TABLE integration_field_values IS 'Field values used in each integration execution';

COMMENT ON COLUMN custom_integrations.http_method IS 'HTTP method for the webhook call (GET or POST)';
COMMENT ON COLUMN custom_integrations.timeout_seconds IS 'Timeout for the webhook call in seconds';
COMMENT ON COLUMN custom_integration_fields.field_type IS 'Data type for the field (text, number, boolean, email, url, date, enum)';
COMMENT ON COLUMN custom_integration_fields.display_order IS 'Order in which fields should be displayed in UI';
COMMENT ON COLUMN ai_agent_integrations.trigger_condition IS 'Condition that triggers this integration (e.g., payment received, lead qualified)';
COMMENT ON COLUMN ai_agent_integrations.execution_order IS 'Order in which integrations should be executed (lower numbers execute first)';
COMMENT ON COLUMN ai_agent_integrations.depends_on_integration IS 'Integration that must execute successfully before this one';
COMMENT ON COLUMN ai_agent_integrations.requires_success IS 'Whether this integration requires the dependency to succeed before executing';
COMMENT ON COLUMN integration_execution_logs.execution_duration_ms IS 'Time taken to execute the integration in milliseconds';

-- ============================
-- Custom Integration Indexes
-- ============================

CREATE INDEX IF NOT EXISTS idx_custom_integrations_active ON custom_integrations(is_active);
CREATE INDEX IF NOT EXISTS idx_custom_integration_headers_integration ON custom_integration_headers(id_integration);
CREATE INDEX IF NOT EXISTS idx_custom_integration_fields_integration ON custom_integration_fields(id_integration);
CREATE INDEX IF NOT EXISTS idx_custom_integration_fields_order ON custom_integration_fields(id_integration, display_order);
CREATE INDEX IF NOT EXISTS idx_ai_agent_integrations_agent ON ai_agent_integrations(id_ai_agent);
CREATE INDEX IF NOT EXISTS idx_ai_agent_integrations_integration ON ai_agent_integrations(id_integration);
CREATE INDEX IF NOT EXISTS idx_ai_agent_integrations_enabled ON ai_agent_integrations(id_ai_agent, is_enabled);
CREATE INDEX IF NOT EXISTS idx_ai_agent_integrations_order ON ai_agent_integrations(id_ai_agent, execution_order);
CREATE INDEX IF NOT EXISTS idx_ai_agent_integrations_dependency ON ai_agent_integrations(depends_on_integration);
CREATE INDEX IF NOT EXISTS idx_integration_execution_logs_agent ON integration_execution_logs(id_ai_agent);
CREATE INDEX IF NOT EXISTS idx_integration_execution_logs_integration ON integration_execution_logs(id_integration);
CREATE INDEX IF NOT EXISTS idx_integration_execution_logs_contact ON integration_execution_logs(id_contact);
CREATE INDEX IF NOT EXISTS idx_integration_execution_logs_executed_at ON integration_execution_logs(executed_at);
CREATE INDEX IF NOT EXISTS idx_integration_field_values_log ON integration_field_values(id_execution_log);
CREATE INDEX IF NOT EXISTS idx_integration_field_values_field ON integration_field_values(id_field);

-- ============================
-- Custom Integration Triggers
-- ============================

CREATE TRIGGER trg_update_custom_integrations BEFORE UPDATE ON custom_integrations
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_update_ai_agent_integrations BEFORE UPDATE ON ai_agent_integrations
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
