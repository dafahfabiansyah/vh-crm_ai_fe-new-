require('dotenv').config();
const express = require("express");
const { Client, LocalAuth, MessageMedia } = require("whatsapp-web.js");
const qrcode = require("qrcode");
const fs = require("fs");
const cors = require("cors");
const multer = require("multer");
const path = require("path");
const axios = require("axios")
const jwt = require("jsonwebtoken");

const app = express();
app.use(express.json());
app.use(cors());
// Ensure media directory exists
if (!fs.existsSync(path.join(__dirname, "media"))) {
  fs.mkdirSync(path.join(__dirname, "media"));
}
app.use("/media", express.static(path.join(__dirname, "media")));

// Environment Variables
const BACKEND_BASE_URL = process.env.BACKEND_BASE_URL || 'http://localhost:8080';
const LOCAL_SERVER_URL = process.env.LOCAL_SERVER_URL || 'http://localhost:3000';
const JWT_SECRET = process.env.JWT_SECRET;
const PORT = process.env.PORT || 3000;

// API Endpoints
const CONTACTS_ENDPOINT = process.env.CONTACTS_ENDPOINT || '/v1/contacts';
const CHATLOGS_ENDPOINT = process.env.CHATLOGS_ENDPOINT || '/v1/chatlogs';
const PLATFORM_INBOX_ENDPOINT = process.env.PLATFORM_INBOX_ENDPOINT || '/v1/platform-inbox';
const PLATFORM_INBOXS_ENDPOINT = process.env.PLATFORM_INBOXS_ENDPOINT || '/v1/platform-inboxs';
const STAGES_ENDPOINT = process.env.STAGES_ENDPOINT || '/v1/stages';
const AGENTS_ENDPOINT = process.env.AGENTS_ENDPOINT || '/v1/agents';
const LEADS_ENDPOINT = process.env.LEADS_ENDPOINT || '/v1/leads';
const PLATFORM_MAPPINGS_ENDPOINT = process.env.PLATFORM_MAPPINGS_ENDPOINT || '/v1/platform_mappings';

// Legacy support
const backendAPI = BACKEND_BASE_URL;
const sessions = {}; // runtime session registry
const contactSessionIds = {}; // Store session_id per contact for AI context continuity
const contactLastAgents = {}; // Store last used agent per contact to detect agent changes

const storage = multer.diskStorage({
  destination: "./media",
  filename: (req, file, cb) => cb(null, Date.now() + "-" + file.originalname),
});
const upload = multer({ storage });

const SESSIONS_DIR = path.join(__dirname, "sessions");

async function syncContact(logData, token, isMedia) {
  const {
    id_platform,
    contact_identifier,
    push_name,
    message,
    timestamp,
    fromMe,
  } = logData;

  try {
    // Look up contact by both contact_identifier and id_platform
    const contactRes = await axios.get(
      `${BACKEND_BASE_URL}${CONTACTS_ENDPOINT}/${contact_identifier}?id_platform=${encodeURIComponent(id_platform)}`,
      {
        headers: { Authorization: `Bearer ${token}` },
        validateStatus: () => true,
      }
    );

    const contactExists = contactRes.status === 200 && contactRes.data?.id;
    const existing = contactExists ? contactRes.data : null;

    // ‚úÖ If the message is from you but contact doesn't exist ‚Üí don't do anything
    if (fromMe && !contactExists) {
      console.warn(`üì≠ Skipping sync for ${contact_identifier} on platform ${id_platform} ‚Äî you messaged first & contact doesn't exist`);
      return null;
    }

    // Log contact creation for same identifier on different platforms
    if (!contactExists) {
      console.log(`üë§ Creating new contact: ${contact_identifier} on platform ${id_platform}`);
    } else {
      console.log(`üë§ Updating existing contact: ${contact_identifier} on platform ${id_platform}`);
    }

    let unreadMessages = 0;
    let lastMessageFromMe = fromMe;
if (!contactExists) {
  unreadMessages = fromMe ? 1 : 0;
  lastMessageFromMe = fromMe;
} else {
  if (fromMe) {
    unreadMessages = 0;
    lastMessageFromMe = false;
  } else {
    unreadMessages = (existing?.unread_messages || 0) + 1;
    lastMessageFromMe = true;
  }
}

    const payload = {
      id_platform,
      contact_identifier,
      push_name: fromMe ? undefined : push_name,
      message,
      timestamp,
      unread_messages: unreadMessages,
      fromMe: lastMessageFromMe,
    };

    const url = `${BACKEND_BASE_URL}${CONTACTS_ENDPOINT}`;

    const res = await axios.post(url, payload, {
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      validateStatus: () => true,
    });

if (res.status === 200 || res.status === 201) {
  const id = res.data?.id || res.data?.contact?.id;
  if (id) return id;
}



    console.warn("‚ö†Ô∏è Failed to sync contact:", res.status, res.data);
    return null;
  } catch (err) {
    console.error("‚ùå Error syncing contact:", err.response?.data || err.message);
    return null;
  }
}

// Load existing sessions from disk
function loadSavedSessions() {
  if (!fs.existsSync(SESSIONS_DIR)) fs.mkdirSync(SESSIONS_DIR);
  const files = fs.readdirSync(SESSIONS_DIR);
  const loadPromises = files.map((file) => {
    const sessionName = file.replace(".json", "");
    const metadataPath = path.join(SESSIONS_DIR, file);

    let token, tenantId, platformName;
    try {
      const metadata = JSON.parse(fs.readFileSync(metadataPath));
      token = metadata.token;
      tenantId = metadata.id_tenant;
      platformName = metadata.platform_name;
    } catch (err) {
      console.warn(`‚ö†Ô∏è Could not read metadata for ${sessionName}`);
    }

    console.log(`üîÅ Restoring session: ${sessionName}`);
    return startSession(sessionName, platformName, tenantId, token);
  });

  Promise.all(loadPromises).then(() => {
    console.log("‚úÖ All sessions restored.");
  });
}

setInterval(async () => {
  for (const [sessionName, sessionData] of Object.entries(sessions)) {
    const client = sessionData.client;
    try {
      const state = await client.getState();
      if (state !== "CONNECTED") {
        console.warn(`üîÑ [${sessionName}] State: ${state}. Reinitializing...`);
        await client.destroy();
        await client.initialize();
      }
    } catch (err) {
      console.error(`‚ùå [${sessionName}] Failed to get state:`, err.message);
    }
  }
}, 5 * 60 * 1000);

async function logOutgoingMessage({ session, number, message, mediaPath = "", isMedia = false }) {
  const sessionObj = sessions[session];
  const token = sessionObj?.token;
  const timestamp = new Date().toISOString();

  const logData = {
    id_platform: session,
    contact_identifier: number,
    push_name: "You",
    message,
    media: mediaPath,
    type: isMedia ? "media" : "text",
    fromMe: true,
    timestamp,
  };

  // Call syncContact to handle unread count + update
  const contactId = await syncContact(logData, token, isMedia);

  if (!contactId) {
    console.warn("‚ö†Ô∏è No contact found ‚Äî skipping chatlog");
    return;
  }

  const chatlogPayload = {
    id_contact: contactId,
    message: message || "",
    type: isMedia ? "media" : "text",
    media: isMedia ? mediaPath : "",
    from_me: true,
    sent_at: timestamp,
  };

  await axios.post(`${BACKEND_BASE_URL}${CHATLOGS_ENDPOINT}`, chatlogPayload, {
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
  });

  console.log("üì° Chatlog sent:", chatlogPayload);
}

function saveSessionName(name) {
  const filePath = path.join(SESSIONS_DIR, `${name}.json`);
  if (!fs.existsSync(filePath)) {
    fs.writeFileSync(filePath, JSON.stringify({ session: name }));
  }
}
const AUTH_DIR = path.join(__dirname, ".wwebjs_auth");

app.delete("/session/:session", async (req, res) => {
  const { session } = req.params;

  const clientData = sessions[session];
  if (!clientData) {
    return res.status(404).json({ error: "Session not found" });
  }

  try {
    // Get token for API calls
    const token = clientData.token;

    // Destroy WhatsApp session
    await clientData.client.destroy();
    delete sessions[session];

    // Delete platform-inbox via API
    if (token) {
      try {
        console.log(`üóëÔ∏è Attempting to delete platform-inbox for session ${session}`);
        await axios.delete(`${BACKEND_BASE_URL}${PLATFORM_INBOX_ENDPOINT}/${session}`, {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          validateStatus: () => true, // Accept any status code
        });
        console.log(`‚úÖ Platform-inbox deleted for session ${session}`);
      } catch (inboxError) {
        console.error(`‚ùå Failed to delete platform-inbox for ${session}:`, inboxError.response?.data || inboxError.message);
      }
    }

    // Add delay to allow client to properly close file handles
    setTimeout(() => {
      try {
        // Remove session JSON file
        const sessionFile = path.join(SESSIONS_DIR, `${session}.json`);
        if (fs.existsSync(sessionFile)) {
          fs.unlinkSync(sessionFile);
          console.log(`üóëÔ∏è Deleted session file: ${sessionFile}`);
        }

        // Remove LocalAuth folder
        const authFolder = path.join(AUTH_DIR, `session-${session}`);
        if (fs.existsSync(authFolder)) {
          fs.rmSync(authFolder, { recursive: true, force: true });
          console.log(`üóëÔ∏è Deleted auth directory: ${authFolder}`);
        }

        console.log(`üóëÔ∏è Deleted session: ${session}`);
      } catch (cleanupError) {
        console.error(`‚ùå Error during session cleanup for ${session}:`, cleanupError.message);
        // Try alternative cleanup method
        try {
          const authFolder = path.join(AUTH_DIR, `session-${session}`);
          if (fs.existsSync(authFolder)) {
            require('child_process').execSync(`rm -rf "${authFolder}"`);
            console.log(`üóëÔ∏è Force deleted auth directory using rm -rf: ${authFolder}`);
          }
        } catch (forceError) {
          console.error(`‚ùå Force cleanup also failed for ${session}:`, forceError.message);
        }
      }
    }, 1000); // 1 second delay

    res.json({ success: true, message: `Session ${session} deleted.` });
  } catch (err) {
    console.error("Delete session error:", err);
    res.status(500).json({ error: "Failed to delete session" });
  }
});

// Start a WhatsApp session
function startSession(sessionName, platformName, tenantId, token) {
  platformName = platformName || sessionName;
  return new Promise((resolve, reject) => {
    if (!token) {
      throw new Error(`‚ùå Token is required for session: ${sessionName}`);
    }
    const metadataPath = path.join(SESSIONS_DIR, `${sessionName}.json`);
    const isRestored = fs.existsSync(metadataPath);
    let resolved = false; 
    const client = new Client({
      authStrategy: new LocalAuth({
        clientId: sessionName,
        dataPath: path.join(__dirname, ".wwebjs_auth"),
      }),
      puppeteer: {
        headless: "new",
        args: [
          "--no-sandbox",
          "--disable-setuid-sandbox",
          "--disable-dev-shm-usage",
          "--disable-gpu",
          "--no-zygote",
          "--disable-accelerated-2d-canvas",
          "--disable-background-timer-throttling",
          "--disable-backgrounding-occluded-windows"
        ],
      },
    });
    
    client.token = token;
    client.sessionName = sessionName;
    const sessionObj = {
      client,
      token,
      qr: null,
      status: "initializing",
      sessionName
    };

sessions[sessionName] = sessionObj;
  const currentSessionName = sessionName;

const earlyMetadata = {
  id: sessionName,
  platform_name: platformName,
  id_tenant: tenantId,
  source_type: "WhatsApp",
  platform_identifier: "pending",
  token,
};
fs.writeFileSync(metadataPath, JSON.stringify(earlyMetadata, null, 2));
    let qrTimeout = null;
    let qrAttemptCount = 0;

    client.on("qr", (qr) => {
      sessionObj.qr = qr;
      sessionObj.status = "waiting_for_scan";
      qrAttemptCount++;
      console.log(`üì≤ [${sessionName}] QR updated (attempt ${qrAttemptCount})`);
      
      // Clear existing timeout if any
      if (qrTimeout) {
        clearTimeout(qrTimeout);
        qrTimeout = null;
      }
      
      // Determine timeout duration based on session type and attempt count
      let timeoutDuration;
      if (!isRestored) {
        // New session creation: 90 seconds
        timeoutDuration = 90_000;
        console.log(`‚è∞ [${sessionName}] Starting 90-second QR timeout for new session`);
      } else if (qrAttemptCount >= 3) {
        // Restored session after 3+ attempts: 30 seconds
        timeoutDuration = 10_000;
        console.log(`‚è∞ [${sessionName}] Starting 30-second QR timeout for restored session (attempt ${qrAttemptCount})`);
      } else {
        // Restored session, first 2 attempts: 90 seconds
        timeoutDuration = 90_000;
        console.log(`‚è∞ [${sessionName}] Starting 90-second QR timeout for restored session (attempt ${qrAttemptCount})`);
      }
      
      qrTimeout = setTimeout(() => {
        if (sessionObj.status === "waiting_for_scan") {
          const timeoutSeconds = timeoutDuration / 1000;
          console.warn(`‚è±Ô∏è QR not scanned within ${timeoutSeconds} seconds for ${sessionName}. Cleaning up session.`);
          client.destroy();
          delete sessions[sessionName];
          
          // Add delay to allow client to properly close file handles
          setTimeout(async () => {
            try {
              const sessionPath = path.join(SESSIONS_DIR, `${sessionName}.json`);
              const localAuthPath = path.join(AUTH_DIR, `session-${sessionName}`);
              const puppeteerCachePath = path.join(__dirname, '.wwebjs_cache', `session-${sessionName}`);
              const puppeteerUserDataPath = path.join(__dirname, '.wwebjs_auth', `session-${sessionName}`);
              
              // Delete session metadata file
              if (fs.existsSync(sessionPath)) {
                fs.unlinkSync(sessionPath);
                console.log(`üóëÔ∏è Deleted session file: ${sessionPath}`);
              }
              
              // Delete authentication directory
              if (fs.existsSync(localAuthPath)) {
                fs.rmSync(localAuthPath, { recursive: true, force: true });
                console.log(`üóëÔ∏è Deleted auth directory: ${localAuthPath}`);
              }
              
              // Delete Puppeteer cache directory
              if (fs.existsSync(puppeteerCachePath)) {
                fs.rmSync(puppeteerCachePath, { recursive: true, force: true });
                console.log(`üóëÔ∏è Deleted Puppeteer cache: ${puppeteerCachePath}`);
              }
              
              // Delete Puppeteer user data directory (additional cleanup)
              if (fs.existsSync(puppeteerUserDataPath)) {
                fs.rmSync(puppeteerUserDataPath, { recursive: true, force: true });
                console.log(`üóëÔ∏è Deleted Puppeteer user data: ${puppeteerUserDataPath}`);
              }
              
              // Clean up any temporary media files for this session
              const mediaDir = path.join(__dirname, 'media');
              if (fs.existsSync(mediaDir)) {
                const mediaFiles = fs.readdirSync(mediaDir);
                mediaFiles.forEach(file => {
                  if (file.includes(sessionName) || file.startsWith('temp-')) {
                    try {
                      fs.unlinkSync(path.join(mediaDir, file));
                      console.log(`üóëÔ∏è Deleted temp media file: ${file}`);
                    } catch (mediaErr) {
                      console.warn(`‚ö†Ô∏è Could not delete media file ${file}:`, mediaErr.message);
                    }
                  }
                });
              }
              
              // Delete platform-inbox via API
              try {
                console.log(`üóëÔ∏è Attempting to delete platform-inbox for session ${sessionName}`);
                await axios.delete(`${BACKEND_BASE_URL}${PLATFORM_INBOX_ENDPOINT}/${sessionName}`, {
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${token}`,
                  },
                  validateStatus: () => true, // Accept any status code
                });
                console.log(`‚úÖ Platform-inbox deleted for session ${sessionName}`);
              } catch (inboxError) {
                console.error(`‚ùå Failed to delete platform-inbox for ${sessionName}:`, inboxError.response?.data || inboxError.message);
              }
              
              console.log(`üóëÔ∏è Complete cache cleanup for session ${sessionName}`);
            } catch (cleanupError) {
              console.error(`‚ùå Error during session cleanup for ${sessionName}:`, cleanupError.message);
              // Try alternative cleanup method with force removal
              try {
                const pathsToClean = [
                  path.join(AUTH_DIR, `session-${sessionName}`),
                  path.join(__dirname, '.wwebjs_cache', `session-${sessionName}`),
                  path.join(__dirname, '.wwebjs_auth', `session-${sessionName}`)
                ];
                
                pathsToClean.forEach(cleanPath => {
                  if (fs.existsSync(cleanPath)) {
                    require('child_process').execSync(`rm -rf "${cleanPath}"`);
                    console.log(`üóëÔ∏è Force deleted: ${cleanPath}`);
                  }
                });
              } catch (forceError) {
                console.error(`‚ùå Force cleanup also failed for ${sessionName}:`, forceError.message);
              }
            }
          }, 1000); // 1 second delay
          
          if (!resolved) {
            reject(new Error(`QR timeout - session deleted after ${timeoutSeconds} seconds`));
          }
        }
      }, timeoutDuration);
    
      if (!resolved) {
        resolved = true;
        resolve(qr); // ‚úÖ Now resolves immediately with the QR
      }
    });
    

    client.on("authenticated", () => {
      sessionObj.status = "authenticated";
      console.log(`üîê [${sessionName}] Authenticated`);
      // Clear QR timeout since session is now authenticated
      if (qrTimeout) {
        clearTimeout(qrTimeout);
        qrTimeout = null;
        console.log(`‚è∞ Cleared QR timeout for ${sessionName} - session authenticated`);
      }
    });

    client.on("ready", () => {
      console.log("üî• Entering client.on('ready')");
    
      // Clear QR timeout as an additional safety measure
      if (qrTimeout) {
        clearTimeout(qrTimeout);
        qrTimeout = null;
        console.log(`‚è∞ Cleared QR timeout for ${sessionName} - session ready`);
      }
    
      try {
        sessionObj.status = "ready";
    
        const platformIdentifier = client.info?.wid?.user || "unknown"; // ‚Üê potential issue

        const metadata = {
          id: sessionName,
          platform_name: platformName,
          id_tenant: tenantId,
          source_type: "WhatsApp",
          platform_identifier: platformIdentifier,
          is_connected: true,
      
          token,
        };
    
        fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
    
        console.log(`‚úÖ [${sessionName}] Ready`);
    
        if (!isRestored && token) {
          console.log(`üéâ [${sessionName}] QR has been scanned and authenticated!`);
    
          axios.post(`${BACKEND_BASE_URL}${PLATFORM_INBOX_ENDPOINT}`, metadata, {
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
          })
          .then((axiosRes) => {
            console.log("‚úÖ Metadata sent:", axiosRes.data);
          })
          .catch((err) => {
            console.error("‚ùå Failed to send metadata:", err.response?.data || err.message);
          });
    
          console.log("üì¶ Metadata:", JSON.stringify(metadata, null, 2));
        }
    
        if (!resolved) {
          resolved = true;
          resolve({
            type: "authenticated",
            ...metadata,
          });
        }
    
      } catch (err) {
        console.error(`‚ùå Error during client.on('ready') for ${sessionName}:`, err);
      }
    });
    



  
  client.on("message_create", async (msg) => {
    try {
           const token = sessions[currentSessionName]?.token;

      if (!token) return;
      
      // Debug: Verify token contains tenant ID
      try {
        const decoded = jwt.verify(token, JWT_SECRET);
        console.log(`üîç Token decoded for session ${currentSessionName}:`, {
          id_tenant: decoded.id_tenant,
          hasIdTenant: !!decoded.id_tenant
        });
        if (!decoded.id_tenant) {
          console.error(`‚ùå Token missing tenant ID for session: ${currentSessionName}`);
        }
      } catch (tokenErr) {
        console.error(`‚ùå Token verification failed for session ${currentSessionName}:`, tokenErr.message);
      }

      // Skip outgoing messages to prevent duplicate logging
      if (msg.fromMe) {
        console.log(`üì§ Skipping outgoing message logging (handled by API endpoint)`);
        return;
      }

      const isMedia = msg.hasMedia;
      console.log(`üîç Message received - isMedia: ${isMedia}, fromMe: ${msg.fromMe}, type: ${msg.type}`);
      
      // Block stickers and voice notes from being sent to backend/AI
      if (msg.type === 'sticker' || msg.type === 'ptt') {
        console.log(`üö´ Blocking ${msg.type} message from backend/AI processing`);
        return;
      }
      
      const contact = await msg.getContact();
      const timestamp = new Date().toISOString();

      const contactIdentifier = contact?.number || "";
        
      console.log(`üìû Contact identifier: ${contactIdentifier}`);

      if (
        !contactIdentifier ||
        msg.from?.endsWith("@g.us") ||
        msg.to?.endsWith("@g.us") ||
        msg.from?.endsWith("@broadcast") ||
        msg.to?.endsWith("@broadcast") ||
        msg.id.remote === "status@broadcast"
      ) {
        return;
      }

      const logData = {
        id_platform: sessionName,
        push_name: contact?.pushname || contact?.name || "Unknown",
        contact_identifier: contactIdentifier,
        jid: msg.from,
        message: msg.body,
        type: isMedia ? "media" : "text",
        timestamp,
        fromMe: msg.fromMe,
        unread_messages: msg.fromMe ? 0 : 1,
      };

      let contactId = null; // üõ†Ô∏è DECLARE contactId before usage

      // üñºÔ∏è Handle media - download and prepare for later upload
      let s3MediaUrl = "";
      let mediaData = null;
      let mediaUrl = null;
      let tempFilename = null;
      
      if (isMedia) {
        console.log(`üñºÔ∏è Processing media message...`);
        const media = await msg.downloadMedia();
        if (media) {
          console.log(`üì• Media downloaded - mimetype: ${media.mimetype}, size: ${media.data?.length || 0} bytes`);
          logData.mimetype = media.mimetype;
          
          // Store media data for later upload after agent assignment is determined
          if (!msg.fromMe) {
            mediaData = media;
            // Save media temporarily and create HTTP URL
            const ext = media.mimetype.split("/")[1];
            tempFilename = `media/temp-${Date.now()}.${ext}`;
            fs.writeFileSync(tempFilename, media.data, "base64");
            mediaUrl = `${LOCAL_SERVER_URL}/media/${path.basename(tempFilename)}`;
            console.log(`üì§ Created temporary media file: ${tempFilename}`);
          } else {
            console.log(`üìù Message is from me, no local saving required`);
          }
        } else {
           console.log(`‚ö†Ô∏è Failed to download media`);
         }
       } else {
         console.log(`üìù No media detected in message`);
       }

      // First try syncContact
      contactId = await syncContact(logData, token, isMedia);

      // If still null and fromMe, try to manually fetch
      if (!contactId && msg.fromMe && contactIdentifier) {
        try {
          const contactLookup = await axios.get(
            `${BACKEND_BASE_URL}${CONTACTS_ENDPOINT}/${contactIdentifier}`,
            {
              headers: { Authorization: `Bearer ${token}` },
              validateStatus: () => true,
            }
          );

          if (contactLookup.status === 200 && contactLookup.data?.id) {
            contactId = contactLookup.data.id;
          }
        } catch (err) {
          console.warn("‚ö†Ô∏è Could not retrieve contact by identifier:", err.response?.data || err.message);
        }
      }

      const chatlogPayload = {
        id_contact: contactId,
        message: msg.body || "",
        type: isMedia ? "media" : "text",
        media: isMedia ? (s3MediaUrl || null) : "",
        from_me: msg.fromMe,
        sent_at: timestamp,
      };

      if (contactId) {
        await axios.post(`${BACKEND_BASE_URL}${CHATLOGS_ENDPOINT}`, chatlogPayload, {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
        });

        console.log("üì° Chatlog sent:", chatlogPayload);
      } else {
        console.warn("‚ö†Ô∏è Contact not found ‚Äî skipping chatlog");
      }
  if (!msg.fromMe && contactId) {
  let assignedTo = null;
  let agentIdentifier = null;
  let shouldRespondWithAI = false;
  
  try {
    // 1. First check if there's an existing lead for this contact AND platform, prioritizing unassigned leads
    console.log("Checking for existing lead for contact:", contactId, "and platform:", sessionName);
    let existingLead = null;
    
    // Get contact info first to check platform match
    console.log("get contact info for platform verification")
    const contactRes = await axios.get(
      `${BACKEND_BASE_URL}${CONTACTS_ENDPOINT}/${contactIdentifier}`,
      {
        headers: { Authorization: `Bearer ${token}` },
        validateStatus: () => true,
      }
    );

    const contact = contactRes?.data;
    const idContact = contact?.id;
    if (!idContact) return;
    
    // Only look for leads if the contact's platform matches the current session platform
    if (contact.id_platform === sessionName) {
      console.log("Platform matches, checking for existing leads for this platform");
      
      // First try to get unassigned leads for this contact
      try {
        const unassignedLeadRes = await axios.get(
          `${BACKEND_BASE_URL}${LEADS_ENDPOINT}/contact/${contactId}?status=unassigned`,
          {
            headers: { Authorization: `Bearer ${token}` },
            validateStatus: () => true,
          }
        );
        
        if (unassignedLeadRes.status === 200 && unassignedLeadRes.data) {
          existingLead = unassignedLeadRes.data;
          console.log("Found unassigned lead for platform:", existingLead.id, "assigned to:", existingLead.assigned_to);
        }
      } catch (error) {
        console.log("Error fetching unassigned leads:", error.message);
      }
      
      // If no unassigned lead found, try to get any existing lead
      if (!existingLead) {
        try {
          const existingLeadRes = await axios.get(
            `${BACKEND_BASE_URL}${LEADS_ENDPOINT}/contact/${contactId}`,
            {
              headers: { Authorization: `Bearer ${token}` },
              validateStatus: () => true,
            }
          );
          
          if (existingLeadRes.status === 200 && existingLeadRes.data) {
            existingLead = existingLeadRes.data;
            console.log("Found existing lead for platform:", existingLead.id, "assigned to:", existingLead.assigned_to, "status:", existingLead.status);
          }
        } catch (error) {
          console.log("Error fetching existing leads:", error.message);
        }
      }
    } else {
      console.log("Platform mismatch - contact platform:", contact.id_platform, "session platform:", sessionName, "- will create new lead");
    }
    
    // Track if we found an existing active lead (not resolved/closed)
    let hasActiveExistingLead = false;
    
    if (existingLead) {
      // Check if the existing lead is active (not resolved/closed)
      const isLeadActive = existingLead.status !== 'resolved' && existingLead.status !== 'closed' && existingLead.status !== 'won' && existingLead.status !== 'lost';
      
      if (isLeadActive && existingLead.assigned_to) {
        hasActiveExistingLead = true;
        assignedTo = existingLead.assigned_to;
        console.log("Using existing active lead assignment:", assignedTo);
        
        // Get agent details for the assigned agent
        try {
          const agentRes = await axios.get(
            `${BACKEND_BASE_URL}${AGENTS_ENDPOINT}/${assignedTo}`,
            {
              headers: { Authorization: `Bearer ${token}` },
              validateStatus: () => true,
            }
          );
          
          if (agentRes.status === 200) {
            agentIdentifier = agentRes.data?.identifier || assignedTo;
            shouldRespondWithAI = agentRes.data?.agent_type === "AI";
            console.log("Using existing lead agent:", assignedTo, "Type:", agentRes.data?.agent_type);
          } else {
            console.log("Could not fetch existing lead agent details, using ID as fallback");
            agentIdentifier = assignedTo;
            shouldRespondWithAI = true; // Default to AI behavior
          }
        } catch (error) {
          console.log("Error fetching existing lead agent details:", error.message);
          agentIdentifier = assignedTo;
          shouldRespondWithAI = true; // Default to AI behavior
        }
      } else {
        console.log("Existing lead is resolved/closed or has no assignment, will create new lead with pipeline defaults");
      }
    } else {
      console.log("No existing lead found, will create new lead with pipeline defaults");
    }

    // 2. Contact info already fetched above for platform verification

    // 3. Get platform inbox by session name (for pipeline) - needed for lead creation
    console.log("get session name for pipeline")
    const inboxRes = await axios.get(
      `${BACKEND_BASE_URL}${PLATFORM_INBOXS_ENDPOINT}/${sessionName}`,
      {
        headers: { Authorization: `Bearer ${token}` },
        validateStatus: () => true,
      }
    );
    const platformInbox = inboxRes?.data;
    const idPipeline = platformInbox?.id_pipeline || null;

    // Get default stage from pipeline - needed for lead creation
    let idStage = null;
    console.log("get ID stage from pipeline")
    if (idPipeline) {
      try {
        // Get all stages for the pipeline and find the default one (stage_order = 0)
        const stagesRes = await axios.get(
          `${BACKEND_BASE_URL}${STAGES_ENDPOINT}/pipeline/${idPipeline}`,
          {
            headers: { Authorization: `Bearer ${token}` },
            validateStatus: () => true,
          }
        );
        
        if (stagesRes.status === 200 && Array.isArray(stagesRes.data)) {
          const defaultStage = stagesRes.data.find(stage => stage.stage_order === 0);
          if (defaultStage) {
            idStage = defaultStage.id;
            console.log("Found default stage (order 0):", idStage);
          } else {
            console.log("No default stage (order 0) found in pipeline");
          }
        } else {
          console.log("Could not fetch stages for pipeline:", stagesRes.status);
        }
      } catch (error) {
        console.log("Error fetching pipeline stages:", error.message);
      }
    }
    
    // Get pipeline defaults if no active existing lead assignment found (for new leads)
    if (!hasActiveExistingLead && !assignedTo && idStage) {
       console.log("get agent from default stage")
       // Get the default stage details again to check for assigned agent
       try {
         const stageRes = await axios.get(
           `${BACKEND_BASE_URL}${STAGES_ENDPOINT}/${idStage}`,
           {
             headers: { Authorization: `Bearer ${token}` },
             validateStatus: () => true,
           }
         );
         
         if (stageRes.status === 200 && stageRes.data) {
           const defaultStage = stageRes.data;
           
           // Check if default stage has an assigned agent
           if (defaultStage.id_agent) {
             console.log("Default stage has assigned agent:", defaultStage.id_agent);
              
              // Get agent details to determine type and identifier
              try {
                const agentRes = await axios.get(
                  `${BACKEND_BASE_URL}${AGENTS_ENDPOINT}/${defaultStage.id_agent}`,
                  {
                    headers: { Authorization: `Bearer ${token}` },
                    validateStatus: () => true,
                  }
                );
                
                if (agentRes.status === 200) {
                  assignedTo = defaultStage.id_agent; // Use agent ID for lead assignment
                  agentIdentifier = agentRes.data?.identifier || defaultStage.id_agent; // Use identifier for chat API
                  shouldRespondWithAI = agentRes.data?.agent_type === "AI";
                  console.log("Using default stage agent:", assignedTo, "Type:", agentRes.data?.agent_type);
                } else {
                  console.log("Could not fetch agent details, using agent ID as fallback");
                  assignedTo = defaultStage.id_agent;
                  agentIdentifier = defaultStage.id_agent;
                  shouldRespondWithAI = true; // Default to AI behavior
                }
              } catch (error) {
                console.log("Error fetching default stage agent details:", error.message);
                assignedTo = defaultStage.id_agent;
                agentIdentifier = defaultStage.id_agent;
                shouldRespondWithAI = true; // Default to AI behavior
              }
            } else {
              console.log("Default stage has no assigned agent, will try platform mapping");
            }
          } else {
            console.log("Could not fetch default stage details");
          }
        } catch (error) {
          console.log("Error fetching default stage details:", error.message);
        }
        
        // Fallback to platform inbox assignment if no stage agent found
        if (!assignedTo && platformInbox?.assigned_to) {
          assignedTo = platformInbox.assigned_to;
          
          // Check if the platform inbox agent is AI or Human
          try {
            const inboxAgentRes = await axios.get(
              `${BACKEND_BASE_URL}${AGENTS_ENDPOINT}/${platformInbox.assigned_to}`,
              {
                headers: { Authorization: `Bearer ${token}` },
                validateStatus: () => true,
              }
            );
            
            if (inboxAgentRes.status === 200) {
              agentIdentifier = inboxAgentRes.data?.identifier || platformInbox.assigned_to;
              shouldRespondWithAI = inboxAgentRes.data?.agent_type === "AI";
              console.log("Using platform inbox assignment:", assignedTo, "Type:", inboxAgentRes.data?.agent_type, "Will respond with AI:", shouldRespondWithAI);
            } else {
              // Fallback if agent details can't be fetched
              agentIdentifier = platformInbox.assigned_to;
              shouldRespondWithAI = false; // Conservative approach - don't auto-respond if unsure
              console.log("Could not fetch platform inbox agent details, will not auto-respond");
            }
          } catch (error) {
            console.log("Error fetching platform inbox agent details:", error.message);
            agentIdentifier = platformInbox.assigned_to;
            shouldRespondWithAI = false; // Conservative approach
          }
        }
     }

    // If no active existing lead and (no pipeline assignment OR platform_inbox has no id_pipeline), get AI agent from platform mapping
    if (!hasActiveExistingLead && (!assignedTo || !idPipeline)) {
      console.log("No pipeline assignment or platform_inbox has no id_pipeline, getting AI agent from platform mapping")
      console.log("Session name:", sessionName)
      console.log("idPipeline:", idPipeline)
      const platformRes = await axios.post(
        `${BACKEND_BASE_URL}${PLATFORM_MAPPINGS_ENDPOINT}/inbox`,
        { id_platform: sessionName },
        {
          headers: { Authorization: `Bearer ${token}` },
          validateStatus: () => true,
        }
      );
      console.log("Platform mapping response:", platformRes?.data);
      console.log("Platform mapping status:", platformRes?.status);
      
      const agentAI = (platformRes?.data || []).find((a) => a.agent_type === "AI");
      console.log("Found AI agent:", agentAI);
      const agentId = agentAI?.id_agent;
      console.log("Agent ID:", agentId);
      
      // If no AI agent found in platform mapping, don't assign any agent
      // Human agents should not trigger AI responses
      if (!agentId && Array.isArray(platformRes?.data) && platformRes.data.length > 0) {
        console.log("No AI agent found in platform mapping, only human agents available - will not auto-respond");
        const humanAgents = platformRes.data.filter(a => a.agent_type === "Human");
        if (humanAgents.length > 0) {
          // Assign the first human agent for lead assignment but don't respond with AI
          assignedTo = humanAgents[0].id_agent;
          agentIdentifier = null; // No agent identifier for AI response
          shouldRespondWithAI = false;
          console.log("Assigned human agent for lead:", assignedTo, "- AI will not respond");
        }
      }
      
      // Get agent details by ID
      if (agentId) {
        try {
          const agentRes = await axios.get(
            `${BACKEND_BASE_URL}${AGENTS_ENDPOINT}/${agentId}`,
            {
              headers: { Authorization: `Bearer ${token}` },
              validateStatus: () => true,
            }
          );
          console.log("Agent details response:", agentRes?.data);
          console.log("Agent details status:", agentRes?.status);
          
          if (agentRes.status === 200) {
            assignedTo = agentId; // Use agent ID for lead assignment
            agentIdentifier = agentRes.data?.identifier || agentId; // Use identifier for chat API
            shouldRespondWithAI = agentRes.data?.agent_type === "AI";
            console.log("Final assignedTo value:", assignedTo, "Agent type:", agentRes.data?.agent_type);
          } else {
            console.log("Agent details API error:", agentRes.status, agentRes.data?.message);
            // Fallback: use the agent ID from platform mapping directly
            assignedTo = agentId;
            agentIdentifier = agentId;
            shouldRespondWithAI = true; // Default to AI behavior
            console.log("Using agent ID from platform mapping as fallback:", assignedTo);
          }
        } catch (error) {
          console.log("Agent details API error:", error.response?.status, error.response?.data?.message);
          // Fallback: use the agent ID from platform mapping directly
          assignedTo = agentId;
          agentIdentifier = agentId;
          shouldRespondWithAI = true; // Default to AI behavior
          console.log("Using agent ID from platform mapping as fallback:", assignedTo);
        }
      } else {
        console.log("No agent ID found, cannot fetch agent details");
        // Final fallback: if no agents found in platform mapping, still create lead without assignment
        if (!assignedTo) {
          console.log("No agents found in platform mapping, creating lead without agent assignment");
          shouldRespondWithAI = false; // Don't respond with AI if no agent assigned
        }
      }
    } else {
      console.log("Using pipeline assignment:", assignedTo);
    }

    // Upload media to agent API if we have media and an assigned agent
    if (mediaData && assignedTo && !msg.fromMe) {
      console.log(`üöÄ Uploading media to agent API for assigned agent: ${assignedTo} (identifier: ${agentIdentifier})`);
      try {
        // Determine session_id for consistency
        const contactKey = `${sessionName}_${contactIdentifier}`;
        let sessionId = contactSessionIds[contactKey] || `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        
        const uploadPayload = {
          media: mediaUrl,
          caption: msg.body || "",
          session_id: sessionId,
          whatsapp: {
            session: sessionName,
            number: contactIdentifier
          }
        };
        
        console.log(`üì§ Uploading image to agent API for agent identifier: ${agentIdentifier}`);
        
        // Debug: Log complete token info before API call
        try {
          const tokenDecoded = jwt.verify(token, JWT_SECRET);
          console.log(`üîç Complete token payload for image upload:`, JSON.stringify(tokenDecoded, null, 2));
          console.log(`üîç Token summary:`, {
            id_tenant: tokenDecoded.id_tenant,
            hasIdTenant: !!tokenDecoded.id_tenant,
            tokenLength: token.length,
            allKeys: Object.keys(tokenDecoded)
          });
          console.log(`üîç Raw token (first 50 chars): ${token.substring(0, 50)}...`);
        } catch (debugErr) {
          console.error(`‚ùå Token debug failed:`, debugErr.message);
        }
        
        const uploadResponse = await axios.post(
          `${BACKEND_BASE_URL}${AGENTS_ENDPOINT}/${agentIdentifier}/whatsapp/image`,
          uploadPayload,
          {
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
            validateStatus: () => true,
          }
        );
        
        if (uploadResponse.status === 200 && uploadResponse.data?.media) {
          s3MediaUrl = uploadResponse.data.media;
          console.log(`‚úÖ Image uploaded successfully, S3 URL: ${s3MediaUrl}`);
        } else {
          console.warn(`‚ö†Ô∏è Image upload failed:`, uploadResponse.status, uploadResponse.data);
        }
        
        // Clean up temporary file
        try {
          fs.unlinkSync(tempFilename);
          console.log(`üóëÔ∏è Cleaned up temporary file: ${tempFilename}`);
        } catch (cleanupErr) {
          console.warn(`‚ö†Ô∏è Failed to cleanup temporary file: ${tempFilename}`, cleanupErr.message);
        }
      } catch (uploadErr) {
        console.error(`‚ùå Failed to upload image to agent API:`, uploadErr.response?.data || uploadErr.message);
        
        // Clean up temporary file even on error
        try {
          if (tempFilename) {
            fs.unlinkSync(tempFilename);
            console.log(`üóëÔ∏è Cleaned up temporary file after error: ${tempFilename}`);
          }
        } catch (cleanupErr) {
          console.warn(`‚ö†Ô∏è Failed to cleanup temporary file after error: ${tempFilename}`, cleanupErr.message);
        }
      }
    }

    // 6. Create lead only if there's actual content
    const hasTextContent = msg.body && msg.body.trim() && msg.body.replace(/[\u200B-\u200F\uFEFF\u202A-\u202E\u2060-\u206F]/g, '').trim();
    if (hasTextContent || (isMedia && s3MediaUrl)) {
      const leadPayload = {
        name: contact?.name || contact?.push_name || contactIdentifier,
        potential_value: 0,
        id_contact: idContact,
        assigned_to: assignedTo,
        id_pipeline: idPipeline,
        id_stage: idStage,
        moved_by: "AI",
        status: "unassigned",
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };
      console.log("post leads")
      console.log(leadPayload)
      await axios.post(`${BACKEND_BASE_URL}${LEADS_ENDPOINT}`, leadPayload, {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      });

      console.log("üéØ Lead created:", leadPayload);
    } else {
      console.log("‚è≠Ô∏è Skipping lead creation - no content in message (empty text and no media)");
    }
  } catch (err) {
    console.error("‚ùå Failed to auto-create lead:", err.response?.data || err.message);
  }

  // Determine which agent to use for AI response
  let finalAgentToUse = agentIdentifier; // Default to pipeline agent
  let finalShouldRespondWithAI = shouldRespondWithAI; // Default to pipeline logic
  
  if (msg.body && assignedTo) {
    try {
      // Get the current lead to check its stage
      const leadRes = await axios.get(
        `${BACKEND_BASE_URL}${LEADS_ENDPOINT}/contact/${contactId}`,
        {
          headers: { Authorization: `Bearer ${token}` },
          validateStatus: () => true,
        }
      );
      
      if (leadRes.status === 200 && leadRes.data) {
        const currentLead = leadRes.data;
        const currentStageId = currentLead.id_stage;
        
        // Get the current stage details to check its id_agent
        const stageRes = await axios.get(
          `${BACKEND_BASE_URL}${STAGES_ENDPOINT}/${currentStageId}`,
          {
            headers: { Authorization: `Bearer ${token}` },
            validateStatus: () => true,
          }
        );
        
        if (stageRes.status === 200 && stageRes.data) {
          const currentStage = stageRes.data;
          const stageAgentId = currentStage.id_agent;
          
          // Debug logging for comparison
          console.log(`üîç Debug comparison:`);
          console.log(`   assignedTo: '${assignedTo}' (type: ${typeof assignedTo})`);
          console.log(`   stageAgentId: '${stageAgentId}' (type: ${typeof stageAgentId})`);
          console.log(`   Strict equality (===): ${assignedTo === stageAgentId}`);
          console.log(`   Loose equality (==): ${assignedTo == stageAgentId}`);
          
          // If assigned_to matches the current stage's id_agent, use assigned_to
          if (assignedTo === stageAgentId) {
            console.log(`‚úÖ Assigned agent (${assignedTo}) matches current stage agent (${stageAgentId}), using assigned agent`);
            
            // Get the assigned agent details
            const assignedAgentRes = await axios.get(
              `${BACKEND_BASE_URL}${AGENTS_ENDPOINT}/${assignedTo}`,
              {
                headers: { Authorization: `Bearer ${token}` },
                validateStatus: () => true,
              }
            );
            
            if (assignedAgentRes.status === 200) {
              finalAgentToUse = assignedAgentRes.data?.identifier || assignedTo;
              finalShouldRespondWithAI = assignedAgentRes.data?.agent_type === "AI";
              console.log(`ü§ñ Using assigned agent: ${assignedTo}, type: ${assignedAgentRes.data?.agent_type}, will respond with AI: ${finalShouldRespondWithAI}`);
            } else {
              console.log("Could not fetch assigned agent details, falling back to pipeline agent");
            }
          } else {
            console.log(`‚ö†Ô∏è Assigned agent (${assignedTo}) does not match current stage agent (${stageAgentId}), using pipeline agent (${agentIdentifier})`);
          }
        } else {
          console.log("Could not fetch current stage details, using pipeline agent");
        }
      } else {
        console.log("Could not fetch current lead, using pipeline agent");
      }
    } catch (error) {
      console.log("Error checking lead/stage details:", error.message, "- using pipeline agent");
    }
  }

  // Send message to agent API only if should respond with AI
  if (msg.body && finalAgentToUse && finalShouldRespondWithAI) {
    try {
      // Determine session_id based on lead status and agent changes
      let sessionId;
      const contactKey = `${sessionName}_${contactIdentifier}`;
      const lastUsedAgent = contactLastAgents[contactKey];
      const hasAgentChanged = lastUsedAgent && lastUsedAgent !== finalAgentToUse;
      let isFirstMessage = false;
      
      try {
        // Check if there's an existing lead for this contact
        const leadRes = await axios.get(
          `${BACKEND_BASE_URL}${LEADS_ENDPOINT}/contact/${contactId}`,
          {
            headers: { Authorization: `Bearer ${token}` },
            validateStatus: () => true,
          }
        );
        
        const existingLead = leadRes.status === 200 ? leadRes.data : null;
        const isLeadResolved = existingLead && (existingLead.status === 'resolved' || existingLead.status === 'closed' || existingLead.status === 'won' || existingLead.status === 'lost');
        
        if (isLeadResolved) {
          // Lead is resolved, generate new session_id for fresh context
          sessionId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          contactSessionIds[contactKey] = sessionId;
          contactLastAgents[contactKey] = finalAgentToUse;
          isFirstMessage = true;
          console.log(`üîÑ Lead resolved - new session_id generated: ${sessionId}`);
        } else if (hasAgentChanged) {
          // Agent has changed, generate new session_id for fresh context
          sessionId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          contactSessionIds[contactKey] = sessionId;
          contactLastAgents[contactKey] = finalAgentToUse;
          isFirstMessage = true;
          console.log(`üîÑ Agent changed from ${lastUsedAgent} to ${finalAgentToUse} - new session_id generated: ${sessionId}`);
        } else {
          // Lead is unassigned/active and agent hasn't changed, reuse existing session_id or create new one
          if (contactSessionIds[contactKey]) {
            sessionId = contactSessionIds[contactKey];
            console.log(`‚ôªÔ∏è Reusing existing session_id: ${sessionId}`);
          } else {
            sessionId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            contactSessionIds[contactKey] = sessionId;
            contactLastAgents[contactKey] = finalAgentToUse;
            isFirstMessage = true;
            console.log(`üÜï New session_id created: ${sessionId}`);
          }
        }
      } catch (err) {
        // If lead check fails, generate new session_id
        console.warn("‚ö†Ô∏è Could not check lead status, generating new session_id:", err.message);
        sessionId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        contactSessionIds[contactKey] = sessionId;
        contactLastAgents[contactKey] = finalAgentToUse;
        isFirstMessage = true;
      }
      
      // Send welcome message immediately after first user message
      if (isFirstMessage) {
        try {
          console.log(`üëã Sending welcome message for first interaction: ${contactKey}`);
          
          // First, fetch the AI agent settings to get the welcome message
          const agentSettingsResponse = await axios.get(`${BACKEND_BASE_URL}/v1/ai/agents/${finalAgentToUse}/settings`, {
            headers: {
              Authorization: `Bearer ${token}`
            },
            validateStatus: () => true,
          });
          
          let welcomeMessage = ""; // Default placeholder
          
          if (agentSettingsResponse.status === 200 && agentSettingsResponse.data?.welcome_message) {
            welcomeMessage = agentSettingsResponse.data.welcome_message;
            console.log(`üìù Retrieved welcome message from AI settings: ${welcomeMessage}`);
          } else {
            console.log(`‚ö†Ô∏è Could not retrieve welcome message from AI settings, using placeholder. Status: ${agentSettingsResponse.status}`);
          }
          
          const welcomeRequest = {
            message: welcomeMessage,
            session_id: sessionId,
            id_platform: sessionName,
            whatsapp: {
              session: sessionName,
              number: msg.from.replace('@c.us', ''),
              platform_identifier: client.info?.wid?.user || sessionName.split('_').pop()
            }
          };
          
          const welcomeResponse = await axios.post(`${BACKEND_BASE_URL}/v1/chat/agent/${finalAgentToUse}/welcome`, welcomeRequest, {
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`
            },
            validateStatus: () => true,
          });
          
          if (welcomeResponse.status === 200 && welcomeResponse.data?.response) {
            // Send welcome message to WhatsApp immediately
            await client.sendMessage(msg.from, welcomeResponse.data.response);
            console.log(`‚úÖ Welcome message sent instantly: ${welcomeResponse.data.response}`);
          } else {
            console.log(`‚ö†Ô∏è Welcome message API returned non-200 status or empty response:`, welcomeResponse.status, welcomeResponse.data);
          }
        } catch (welcomeErr) {
          console.error("‚ùå Failed to send welcome message:", welcomeErr.response?.data || welcomeErr.message);
        }
      }

      // Show typing indicator before processing AI request
      try {
        const chat = await msg.getChat();
        await chat.sendStateTyping();
        console.log(`‚å®Ô∏è Typing indicator sent for chat: ${msg.from}`);
      } catch (typingErr) {
        console.warn(`‚ö†Ô∏è Failed to send typing indicator:`, typingErr.message);
      }

      const chatRequest = {
        message: msg.body,
        session_id: sessionId,
        id_platform: sessionName,
        whatsapp: {
          session: sessionName,
          number: msg.from.replace('@c.us', ''),
          platform_identifier: client.info?.wid?.user || sessionName.split('_').pop()
        }
      };

      const chatResponse = await axios.post(`${BACKEND_BASE_URL}${AGENTS_ENDPOINT}/${finalAgentToUse}/whatsapp`, chatRequest, {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`
        },
        validateStatus: () => true,
      });

      // Clear typing indicator after AI processing
      try {
        const chat = await msg.getChat();
        await chat.clearState();
        console.log(`üõë Typing indicator cleared for chat: ${msg.from}`);
      } catch (clearErr) {
        console.warn(`‚ö†Ô∏è Failed to clear typing indicator:`, clearErr.message);
      }

      console.log("ü§ñ Message sent to agent WhatsApp API:", chatRequest);
      
      if (chatResponse.status !== 200) {
        console.log("‚ö†Ô∏è WhatsApp API returned non-200 status:", chatResponse.status, chatResponse.data);
      } else {
        console.log("üí¨ WhatsApp API response:", chatResponse.data);
      }
    } catch (err) {
      console.error("‚ùå Failed to send message to agent WhatsApp API:", err.response?.data || err.message);
      if (err.response) {
        console.log("Error response:", err.response.status, err.response.data);
      }
    }
  } else if (msg.body && !finalAgentToUse) {
    console.warn("‚ö†Ô∏è No agent found - message not sent to agent API");
  } else if (msg.body && finalAgentToUse && !finalShouldRespondWithAI) {
    console.log("‚ÑπÔ∏è Human agent assigned - AI will not respond, message logged normally");
  } else if (msg.body && !assignedTo) {
    console.log("‚ÑπÔ∏è No agent assigned - message logged normally without AI response");
  }
}
    } catch (err) {
      console.error("‚ùå Failed to handle incoming message:", err.response?.data || err.message);
    }
  

  });




    

    client.initialize().then(() => {
      console.log(`üöÄ Initialized ${sessionName}`);
    }).catch((err) => {
      console.error(`‚ùå Initialization error for ${sessionName}:`, err);
    });
    
  });
}

    





// POST /create-session
app.post("/create-session", async (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Missing or invalid Authorization header" });
  }

  const token = authHeader.split(" ")[1];
  let decoded;
  try {
    decoded = jwt.verify(token, JWT_SECRET);
  } catch (err) {
    return res.status(401).json({ error: "Invalid or expired token" });
  }

  const tenantId = decoded.id_tenant; // comes from Go's JWT
  const { session } = req.body;
  if (!session) return res.status(400).json({ error: "Session name required" });

  const cleanSessionName = session.toLowerCase().replace(/\s+/g, "_");
  const sessionId = `${tenantId}_${cleanSessionName}`;

  if (sessions[sessionId]) {
    return res.status(409).json({ error: "Session already exists" });
  }

  try {
    const qr = await startSession(sessionId, session, tenantId, token);
    saveSessionName(sessionId);

    sessions[sessionId].token= token
    const base64QR = await qrcode.toDataURL(qr);

    return res.json({
      success: true,
      message: "Session created. Scan QR to login.",
      session: sessionId,
      status: "waiting_for_scan",
      qr: base64QR,
    });
  } catch (err) {
    console.error("Session init error", err);
    return res.status(500).json({ error: "Failed to create session" });
  }
});

// POST /send-message
app.post("/send-message", async (req, res) => {
  const { session, number, message } = req.body;
  if (!session || !number || !message) {
    return res.status(400).json({ error: "Missing fields" });
  }

  const clientObj = sessions[session];
  if (!clientObj || clientObj.status !== "ready") {
    return res.status(400).json({ error: "Session not ready or not found" });
  }

  try {
    const chatId = number.includes("@c.us") ? number : `${number}@c.us`;
    
    // Send the message
    await clientObj.client.sendMessage(chatId, message);
    console.log(`üì§ [${session}] SENT ‚Üí ${chatId}: ${message}`);

    // Mark chat as read (send read receipt)
    try {
      const chat = await clientObj.client.getChatById(chatId);
      await chat.sendSeen();
      console.log(`‚úÖ Read receipt sent for chat: ${chatId}`);
    } catch (readErr) {
      console.warn(`‚ö†Ô∏è Failed to send read receipt:`, readErr.message);
    }

    await logOutgoingMessage({ session, number, message });
    return res.json({ success: true });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Failed to send message" });
  }
});
// POST /send-image
app.post("/send-image", upload.single("file"), async (req, res) => {
  const { session, number, caption } = req.body;
  const file = req.file;

  if (!session || !number || !file) {
    return res.status(400).json({ error: "Missing fields" });
  }

  const clientObj = sessions[session];
  if (!clientObj || clientObj.status !== "ready") {
    return res.status(400).json({ error: "Session not ready or not found" });
  }

  try {
    const chatId = number.includes("@c.us") ? number : `${number}@c.us`;
    const media = MessageMedia.fromFilePath(file.path);
    const msg = await clientObj.client.sendMessage(chatId, media, { caption });

    const contact = await msg.getContact();

    return res.json({
      success: true,
      message: {
        from: "server",
        to: contact.pushname || contact.name || number,
        number,
        jid: chatId,
        caption,
        mediaType: media.mimetype,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to send image" });
  }
});

// GET /status/:session
app.get("/status/:session", (req, res) => {
  const { session } = req.params;
  if (!sessions[session]) {
    return res.status(404).json({ error: "Session not found" });
  }
  res.json({ session, status: sessions[session].status });

});



app.get("/qr/:session", (req, res) => {
  const { session } = req.params;
  const sessionData = sessions[session];

  if (!sessionData) {
    return res.status(404).json({ error: "Session not found" });
  }

  if (sessionData.status !== "waiting_for_scan") {
    return res.status(400).json({ error: "Session is not waiting for QR scan" });
  }

  if (!sessionData.qr) {
    return res.status(500).json({ error: "QR code not available yet" });
  }

  qrcode.toDataURL(sessionData.qr)
    .then((qrImage) => {
      res.json({
        session,
        qr: qrImage,
      });
    })
    .catch((err) => {
      console.error("QR encode error", err);
      res.status(500).json({ error: "Failed to generate QR image" });
    });
});
// POST /send-media
app.post("/send-media", upload.single("file"), async (req, res) => {
  const { session, number, caption } = req.body;
  const file = req.file;

  if (!session || !number || !file) {
    return res.status(400).json({ error: "Missing fields" });
  }

  const clientObj = sessions[session];
  if (!clientObj || clientObj.status !== "ready") {
    return res.status(400).json({ error: "Session not ready or not found" });
  }

  try {
    const chatId = number.includes("@c.us") ? number : `${number}@c.us`;
    const media = MessageMedia.fromFilePath(file.path);
    await clientObj.client.sendMessage(chatId, media, { caption });
    console.log(`üì§ [${session}] Sent media to ${chatId}`);

    // Mark chat as read (send read receipt)
    try {
      const chat = await clientObj.client.getChatById(chatId);
      await chat.sendSeen();
      console.log(`‚úÖ Read receipt sent for media chat: ${chatId}`);
    } catch (readErr) {
      console.warn(`‚ö†Ô∏è Failed to send read receipt for media:`, readErr.message);
    }

    await logOutgoingMessage({
      session,
      number,
      message: caption || "(media)",
      mediaPath: file.path,
      isMedia: true,
    });

    return res.json({ success: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to send media" });
  }
});

// POST /send-media-s3
app.post("/send-media-s3", async (req, res) => {
  const { session, number, caption, s3_url } = req.body;

  if (!session || !number || !s3_url) {
    return res.status(400).json({ error: "Missing fields: session, number, and s3_url are required" });
  }

  const clientObj = sessions[session];
  if (!clientObj || clientObj.status !== "ready") {
    return res.status(400).json({ error: "Session not ready or not found" });
  }

  try {
    const chatId = number.includes("@c.us") ? number : `${number}@c.us`;
    
    // Download media from S3 URL
    const response = await axios.get(s3_url, {
      responseType: 'arraybuffer',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    // Get content type from response headers first
    let contentType = response.headers['content-type'];
    let fileExtension = 'jpg'; // default
    
    // If no content type from headers, detect from URL
    if (!contentType) {
      const urlLower = s3_url.toLowerCase();
      if (urlLower.includes('.jpg') || urlLower.includes('.jpeg')) {
        contentType = 'image/jpeg';
        fileExtension = 'jpg';
      } else if (urlLower.includes('.png')) {
        contentType = 'image/png';
        fileExtension = 'png';
      } else if (urlLower.includes('.gif')) {
        contentType = 'image/gif';
        fileExtension = 'gif';
      } else if (urlLower.includes('.webp')) {
        contentType = 'image/webp';
        fileExtension = 'webp';
      } else {
        contentType = 'image/jpeg';
        fileExtension = 'jpg';
      }
    } else {
      // Extract extension from content type
      fileExtension = contentType.split('/')[1] || 'jpg';
    }
    
    // Ensure it's actually an image content type
    if (!contentType.startsWith('image/')) {
      contentType = 'image/jpeg'; // Force image type
      fileExtension = 'jpg';
    }
    
    console.log(`üìã Detected content type: ${contentType}, extension: ${fileExtension} for URL: ${s3_url}`);
    
    // Convert buffer to base64
    const base64Data = Buffer.from(response.data).toString('base64');
    
    // Use a more descriptive filename
    const filename = `whatsapp_image_${Date.now()}.${fileExtension}`;
    const media = new MessageMedia(contentType, base64Data, filename);
    
    // Send the media message
    const sentMessage = await clientObj.client.sendMessage(chatId, media, { caption });
    console.log(`üì§ [${session}] Sent S3 media to ${chatId} from URL: ${s3_url}`);
    console.log(`‚úÖ Message sent with ID: ${sentMessage.id._serialized}`);

    // Mark chat as read (send read receipt)
    try {
      const chat = await clientObj.client.getChatById(chatId);
      await chat.sendSeen();
      console.log(`‚úÖ Read receipt sent for S3 media chat: ${chatId}`);
    } catch (readErr) {
      console.warn(`‚ö†Ô∏è Failed to send read receipt for S3 media:`, readErr.message);
    }

    await logOutgoingMessage({
      session,
      number,
      message: caption || "(S3 media)",
      mediaPath: s3_url,
      isMedia: true,
    });

    return res.json({ 
      success: true, 
      message: "Media sent successfully from S3 URL",
      messageId: sentMessage.id._serialized,
      contentType: contentType
    });
  } catch (err) {
    console.error("Failed to send S3 media:", err.response?.data || err.message);
    console.error("Error details:", {
      status: err.response?.status,
      statusText: err.response?.statusText,
      url: s3_url
    });
    res.status(500).json({ error: "Failed to send media from S3 URL", details: err.message });
  }
});

loadSavedSessions();

// Start server
app.listen(PORT, () => {
  console.log(`üöÄ API server running at ${LOCAL_SERVER_URL}`);
  console.log(`üì° Backend API: ${BACKEND_BASE_URL}`);
});

// Graceful shutdown handlers
process.on('SIGINT', async () => {
  console.log('\nüõë Server shutting down...');
  console.log(`üìä Found ${Object.keys(sessions).length} sessions to update`);
  
  // Update all active sessions to disconnected
  for (const sessionName in sessions) {
    const sessionData = sessions[sessionName];
    console.log(`üîç Processing session: ${sessionName}, has token: ${!!sessionData?.token}`);
    
    if (sessionData && sessionData.token) {
      try {
        const updateUrl = `${BACKEND_BASE_URL}${PLATFORM_INBOX_ENDPOINT}/${sessionName}`;
        console.log(`üì§ Sending PATCH to: ${updateUrl}`);
        
        await axios.patch(updateUrl, {
          is_connected: false
        }, {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${sessionData.token}`
          }
        });
        console.log(`‚úÖ Updated platform inbox status for session: ${sessionName}`);
      } catch (err) {
        console.error(`‚ùå Failed to update platform inbox for ${sessionName}:`, err.response?.data || err.message);
      }
    } else {
      console.warn(`‚ö†Ô∏è Skipping session ${sessionName} - no token available`);
    }
  }
  
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\nüõë Server shutting down...');
  console.log(`üìä Found ${Object.keys(sessions).length} sessions to update`);
  
  // Update all active sessions to disconnected
  for (const sessionName in sessions) {
    const sessionData = sessions[sessionName];
    console.log(`üîç Processing session: ${sessionName}, has token: ${!!sessionData?.token}`);
    
    if (sessionData && sessionData.token) {
      try {
        const updateUrl = `${BACKEND_BASE_URL}${PLATFORM_INBOX_ENDPOINT}/${sessionName}`;
        console.log(`üì§ Sending PATCH to: ${updateUrl}`);
        
        await axios.patch(updateUrl, {
          is_connected: false
        }, {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${sessionData.token}`
          }
        });
        console.log(`‚úÖ Updated platform inbox status for session: ${sessionName}`);
      } catch (err) {
        console.error(`‚ùå Failed to update platform inbox for ${sessionName}:`, err.response?.data || err.message);
      }
    } else {
      console.warn(`‚ö†Ô∏è Skipping session ${sessionName} - no token available`);
    }
  }
  
  process.exit(0);
 });
